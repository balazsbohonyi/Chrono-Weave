# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**ChronoWeave** is an interactive historical timeline visualization app built with React, Vite, and AI-powered insights. It displays historical figures and events in an interactive canvas, with relationship tracing and contextual discovery features powered by either Google Gemini or OpenRouter APIs.

## Quick Start Commands

```bash
# Install dependencies
npm install

# Development server (runs on http://localhost:3000)
npm run dev

# Production build
npm run build

# Preview production build
npm run preview
```

### Environment Setup

Set the `GEMINI_API_KEY` in `.env.local` to your Google Gemini API key. The app will fallback to Gemini if OpenRouter is not configured in settings.

## Architecture Overview

### Core Layers

1. **UI Layer** (`App.tsx` + `components/`)
   - Main orchestrator managing all state and user interactions
   - State includes: figure data, selections, search results, relationship tracing, discoveries
   - Handles AI service switching between Gemini and OpenRouter

2. **AI Service Layer** (`services/geminiService.ts`, `openRouterService.ts`)
   - Both implement the `IAIService` interface defined in `types.ts`
   - Core methods:
     - `fetchHistoricalFigures()`: Generate figures for a time range
     - `fetchRelatedFigures()`: Find relationships between figures
     - `discoverRelatedFigures()`: Expand timeline with new related figures
     - `fetchRelationshipExplanation()`: Explain connection between two figures
     - `fetchFigureDeepDive()`: Generate detailed biography/quotes

3. **Data Fetching** (`services/wikiService.ts`)
   - Fetches figure images and descriptions from Wikipedia
   - Used for supplementing AI-generated data with real information

4. **Canvas Rendering** (`components/TimelineCanvas.tsx`)
   - Main visualization using canvas rendering (not SVG)
   - Handles figure positioning in 2D space (time on X-axis, layout levels on Y-axis)
   - Manages hover/click interactions and relationship line drawing
   - Uses a layout algorithm to avoid bar overlaps

### Key Concepts

- **Figures**: Historical people or events with birth/death years and category (ARTISTS, SCIENTISTS, etc.)
- **Relationship Tracing**: User clicks a figure to see connected figures visualized as relationship bars
- **Discovery**: Expand the timeline by discovering new figures related to an existing one
- **Layout Levels**: Figures are distributed across Y-axis levels using a collision-avoidance algorithm
- **Caching**: Relationship explanations and deep dives are cached in `localStorage` using keys like `chrono_rel_${sourceId}_${targetId}`

## State Management Pattern

App.tsx manages most state directly with `useState`. Key state groups:

- **Timeline Data**: `figures`, `config` (start/end years)
- **Selection State**: `selectedYear`, `selectedFigures`, `highlightedFigureIds`
- **Interaction State**: `relationshipState`, `popoverState`, `isSidebarCollapsed`
- **Discovery State**: `newlyDiscoveredIds`, `discoverySourceId`, `knownRelationships`
- **UI State**: `selectedCategories`, `isLegendOpen`, `isSettingsOpen`

State updates are passed down as callbacks to child components (ControlPanel, TimelineCanvas, Sidebar, etc.).

## Important Implementation Details

### Figures Generation
- Figures are generated by AI in chunks (per century) for the requested time range
- Each figure has a unique `id` based on name, year range, and index
- The `shortDescription` field is AI-generated during fetch and may be different from Wikipedia data

### Relationship Discovery Process
1. User hovers over a figure and clicks the action bar's "Discover" button
2. App filters existing figure names to avoid duplicates
3. AI generates new related figures with birth/death years
4. New figures are added to the main figures array
5. Relationship state updates to show connections between source and newly discovered figures
6. Toast notification lists newly discovered figures

### Layout Algorithm
- Figures are positioned on a 2D canvas to avoid overlaps
- Y-position (level) is determined by collision detection
- `figureLevels` Map tracks figure ID â†’ layout level for sidebar sorting
- When building a new timeline, all layout levels are recalculated

### Performance Considerations
- Figure details (images, descriptions) are fetched lazily via `fetchBatchFigureDetails()`
- Relationship explanations are cached in localStorage to avoid redundant AI calls
- Canvas rendering uses context for performance (not re-rendering React components for every figure)

## Component Structure

- **TimelineCanvas**: Main visualization, canvas-based rendering
- **ControlPanel**: Top controls (year range, search, settings, legend toggle)
- **Sidebar**: Left panel showing figures for selected year or global list
- **RelationshipPopover**: Modal showing relationship/deep-dive information
- **SettingsDialog**: Configure AI provider (Gemini vs OpenRouter)
- **Legend**: Category filter legend (toggles category visibility)
- **Toast**: Notification system
- **ActionBar**: Hover toolbar with Discover/Trace/Inspect buttons
- **FloatingToolbar**: Secondary interaction toolbar

## Configuration Constants

See `constants.ts` for:
- `CATEGORY_LIST`: Available figure categories
- `HISTORICAL_FIGURES_COUNT`: Total figures to generate
- `HISTORICAL_FIGURES_PER_CENTURY_CHUNK`: Figures per century chunk
- `HISTORICAL_EVENTS_PER_CENTURY_CHUNK`: Events per century chunk

## Common Development Workflows

### Adding a New AI Service
1. Create new class implementing `IAIService` interface in `services/`
2. Implement all 5 required methods
3. Add provider selection logic in `SettingsDialog.tsx` and `initializeService()` in App.tsx

### Modifying Timeline Rendering
- Changes to figure positioning, colors, or interaction in `TimelineCanvas.tsx`
- Layout algorithm is in the canvas render logic
- Hover/click handlers call methods passed from App.tsx

### Adding New Figure Categories
1. Add category to `FigureCategory` type in `types.ts`
2. Update `CATEGORY_LIST` in `constants.ts`
3. Update AI prompts in both `geminiService.ts` and `openRouterService.ts`
4. Add color assignment in `TimelineCanvas.tsx` legend

### Debugging AI Service Issues
- Check browser console for `[Gemini]` or `[OpenRouter]` log messages
- Verify API key in `.env.local` or settings
- Check network tab for failed API calls
- Review service retry logic in `services/utils.ts`

## Testing Tips

- Use narrow year ranges (e.g., 1400-1500) for quick testing
- Check localStorage for cached data using `chrono_rel_*` or `chrono_deepdive_*` keys
- Provider/model selection is saved to localStorage and persists across sessions
